# Flashing From Web to FPGA: A Winding Tale
> Alina Shah, Ankur Dahal, Ellis Brown. May 2023

Our initial plan was to use the WebUSB API to directly flash the binary to FPGA from the website, without having the need to download the bitstream and use an external app/iceprog to flash to the FPGA. To do this, we spent more than 100 hours researching different avenues to solve this problem. Ultimately, we were unsuccessful, but learned a lot along the way.

###  Diving into Webassembly and WASM
Since we were planning on flashing directly from the web to the FPGA, one of the initial ideas we had was to use webassembly and wasm iceprog binary to flash bitstream to the FPGA. The first step in doing this was to actually obtain a webassembly compatible iceprog binary which we could then run on the web application. This led to a very deep rabbit hole of trying to build a wasm binary from a C source file, which was not easy to do. We also needed to interface with the USBs from WebAssembly, which we did not have a solution to, at the time.  Therefore, after several hours of promising research, we had to abandon the webassembly approach and had to look elsewhere to solve this problem. 

### C → JS
Failure of webassembly and wasm gave rise to us making a complete overhaul and re-writing iceprog in javascript so we could simply run it on the frontend. We naively converted all of iceprog’s source code from C to JavaScript, not giving it any thought until the very last minute. Of course it did not work, for the C code heavily relied on libusb API calls and it was not possible to interface with libusb library from the web with JS. Therefore, we dived deep into another rabbit hole – how can we make libusb API calls available on the web so we can call them using JS? There were some interesting repositories we came across while trying to solve this problem (like [https://github.com/marcnewlin/webusb-libusb-shim](https://github.com/marcnewlin/webusb-libusb-shim) and [https://github.com/Shaped/webusb-ftdi](https://github.com/Shaped/webusb-ftdi) but again, there were one or two issues that kept popping up that prevented us from actually being able to flash to the FPGA. They both seemed like they would work and we could see the lights blinking on the board when we tried flashing sample binaries to the FPGA, which told us that some sort of communication was happening with the board from the web! To further investigate this, we used a digital discovery to investigate the bits being sent from/to the FPGA but every time we flashed, the result was nondeterministic, which made debugging very difficult. Furthermore, trying to read the flash ID of the chip on the FPGA did not work with this approach. We also tried capturing the USB packets using Wireshark to see what was going on, but unfortunately, dissecting hundreds of thousands of USB packets and trying to look for this one thing was too tedious and time-consuming. After countless hours and three tired CS majors trying to work on a heavily-EE focused problem, we decided to move to our mitigation plan.

### The GUI
We eventually decided to pivot from flashing directly from the website to flashing from a student’s local computer to the FPGA. We knew this was a solvable problem and could be done by bundling iceprog into a simple GUI wrapper. To create a local application for flashing bin files from a student’s laptop to the FPGA, we used PyInstaller to build the GUI natively on every platform we intended to support (Linux, Mac Intel, Mac Arm64, Windows, Ubuntu). Students can use this application to upload a bin file and flash it directly to the FPGA. The output of the flashing will be shown in an output box on the GUI to help students understand if it was successful or not. The installers for our FlashToFPGA application are on our GitHub (https://github.com/Ellis-Brown/iceprog) and can be installed on any of our supported platforms. We believe this application will simplify the process of flashing for those who are part of the FPGA community and are excited to see if there are any new developments on flashing directly from a website to the FPGA. 

