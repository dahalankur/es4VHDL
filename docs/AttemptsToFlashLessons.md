# Flashing From Web to FPGA: A Winding Tale
> Alina Shah, Ankur Dahal, Ellis Brown. May 2023

Our initial plan was to use the WebUSB API to directly flash the binary to FPGA from the website, without having the need to download the bitstream and use an external app/iceprog to flash to the FPGA. To do this, we spent more than 100 hours researching different avenues to solve this problem. Ultimately, we were unsuccessful, but learned a lot along the way.

###  Diving into Webassembly and WASM
Since we were planning on flashing directly from the web to the FPGA, one of the initial ideas we had was to use webassembly and wasm iceprog binary to flash bitstream to the FPGA. The first step in doing this was to actually obtain a webassembly compatible iceprog binary which we could then run on the web application. This led to a very deep rabbit hole of trying to build a wasm binary from a C source file, which was not easy to do. We also needed to interface with the USBs from WebAssembly, which we did not have a solution to, at the time.  Therefore, after several hours of promising research, we had to abandon the webassembly approach and had to look elsewhere to solve this problem. 

### C → JS
Failure of webassembly and wasm gave rise to us making a complete overhaul and re-writing iceprog in javascript so we could simply run it on the frontend. We naively converted all of iceprog’s source code from C to JavaScript, not giving it any thought until the very last minute. Of course it did not work, for the C code heavily relied on libusb API calls and it was not possible to interface with libusb library from the web with JS. Therefore, we dived deep into another rabbit hole – how can we make libusb API calls available on the web so we can call them using JS? There were some interesting repositories we came across while trying to solve this problem (like [https://github.com/marcnewlin/webusb-libusb-shim](https://github.com/marcnewlin/webusb-libusb-shim) and [https://github.com/Shaped/webusb-ftdi](https://github.com/Shaped/webusb-ftdi) but again, there were one or two issues that kept popping up that prevented us from actually being able to flash to the FPGA. They both seemed like they would work and we could see the lights blinking on the board when we tried flashing sample binaries to the FPGA, which told us that some sort of communication was happening with the board from the web! To further investigate this, we used a digital discovery to investigate the bits being sent from/to the FPGA but every time we flashed, the result was nondeterministic, which made debugging very difficult. Furthermore, trying to read the flash ID of the chip on the FPGA did not work with this approach. We also tried capturing the USB packets using Wireshark to see what was going on, but unfortunately, dissecting hundreds of thousands of USB packets and trying to look for this one thing was too tedious and time-consuming. After countless hours and three tired CS majors trying to work on a heavily-EE focused problem, we decided to move to our mitigation plan.

### The GUI
We eventually decided to pivot from flashing directly from the website to flashing from a student’s local computer to the FPGA. We knew this was a solvable problem and could be done by bundling iceprog into a simple GUI wrapper. To create a local application for flashing bin files from a student’s laptop to the FPGA, we used PyInstaller to build the GUI natively on every platform we intended to support (Linux, Mac Intel, Mac Arm64, Windows, Ubuntu). Students can use this application to upload a bin file and flash it directly to the FPGA. The output of the flashing will be shown in an output box on the GUI to help students understand if it was successful or not. The installers for our FlashToFPGA application are on our GitHub (https://github.com/Ellis-Brown/iceprog) and can be installed on any of our supported platforms. We believe this application will simplify the process of flashing for those who are part of the FPGA community and are excited to see if there are any new developments on flashing directly from a website to the FPGA. 

### Next Steps
For future engineers who are looking to solve the web to FPGA flashing problem, we recommend you start with this Github repository, which actually was able to communicate with the board. It certainly sent data back and forth (feel free to grab a Digital Discovery and test it out yourself). However, the behavior of this tool was not fully correct, and there are some unexplained differences between this tool and iceprog.c. https://github.com/Obijuan/Web-iceprog. 

Take a look at `async function set_cs_creset(cs_b, creset_b)` on [line 427 of test-01.js](https://github.com/Obijuan/Web-iceprog/blob/main/test-01.js#L427).  This uses `0x93` as the direction, but [iceprog uses `0x03`](https://github.com/YosysHQ/icestorm/blob/master/iceprog/iceprog.c). Small changes like this may be related to why the program does not function as intended, but our tests were inconclusive. Additionally, Web-iceprog has a [queue buffer](https://github.com/Obijuan/Web-iceprog/blob/main/test-01.js#L787) for reading data from the board, which seems not to behave as intended when actually reading the data. We suspect this relates to the following problem. The tool struggles to read the proper flash ID of the FPGA and the ID that is read is inconsistent. This non-deterministic behavior made it difficult to debug what exactly was happening and fix the functionality. Although this project has problems and does not fully work, it seems to be the best starting point given it is the only solution that actually sends data between the devices. We wish you the best of luck in figuring out this problem and hope to see a solution to it one day!

